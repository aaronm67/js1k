<!doctype html>
<html>
    <head>
        <title>JS1k, 1k demo submission [ID]</title>
        <meta charset="utf-8" />
    </head>
    <body>
        <canvas id="c"></canvas>
        <script>
            var b = document.body;
            var c = document.getElementsByTagName('canvas')[0];
            var a = c.getContext('2d');
            document.body.clientWidth; // fix bug in webkit: http://qfox.nl/weblog/218
        </script>
        <script>    
    // initialize an empty multidimentional array of "height(l)" tall into k"
    
(function() {

//var b = document.body;
var c = document.getElementsByTagName('canvas')[0];
var a = c.getContext('2d');
var holder;
var boxWidth;
var boxHeight;
var boxSize;
var A;
var B;
var gridWidth;
var gridHeight;
var innerWidth = window.innerWidth;
var innerHeight = window.innerHeight;
var generation;
var updateAndDraw;
var isDragging;
var grid;
var interval;
var g;
var v;
var w;
var G;
var neighbors;

  function initializeEmptyMatrix() {
    holder = [];for(g = 0;g < boxHeight;g++) holder[g] = [];
  }

  // update
    function update() {
        initializeEmptyMatrix(); // initialize K as an empty array
        for(v = 0;v < boxHeight;v++) { // loop to width
            for(w = 0;w < boxWidth;w++) { // loop to height
                neighbors = grid[v][w] ? -1 : 0; // don't include "self" for neighbors
                for(g = -1;2 > g;g++) { // loop through squares around, if "live", increment neighbors
                  for(G = -1;2 > G;G++) {
                    grid[(boxHeight + (v + g)) % boxHeight][(boxWidth + (w + G)) % boxWidth] && neighbors++;
                  }
                }
                // if neighbors 2 or 3 and live, live
                // if neighbors 3 and dead, live
                grid[v][w] ? 1 < neighbors && 4 > neighbors && (holder[v][w] = 1) : 3 == neighbors && (holder[v][w] = 1);
            }
        }
        grid = holder;
        generation++;
    }

  // draw();
    function draw() {
        for(v = 0;v < boxHeight;v++) {
            for(w = 0;w < boxWidth;w++) {
                //c.font = e + "px serif";
                a.fillStyle = grid[v][w] ? "red" : "#eee";
                a.font =  (boxSize +8) + "pt serif";
                //a.fillText("â– ", w * boxSize + 1, v * boxSize + 1, boxSize * 2);
                a.fillRect(w * boxSize + 1, v * boxSize + 1,  boxSize - 1, boxSize - 1);
            }
        }
    }

    
    A = innerWidth-100;
    B = innerHeight-200;
    boxSize = ~~(innerWidth/20);
    
    gridWidth = ~~(A / boxSize) * boxSize;
    gridHeight = ~~(B / boxSize) * boxSize;
    

    // # of boxes (width)
    boxWidth = gridWidth / boxSize;
    // # of boxes (height)
    boxHeight = gridHeight / boxSize;
    // generation counter
    generation = 0;

    c.width = A;
    c.height = B;

    c.onmouseup = updateAndDraw = function() { interval = setInterval( function() { update();draw(); }, 99); isDragging = 0; };
    c.onmousedown = function() { isDragging=1;clearInterval(interval); };
    c.onmousemove = c.onclick = function(event){
        /* works all browsers
        v = ~~((d.clientY - c.offsetTop) / e),
        d = ~~((d.clientX - c.offsetLeft) / e);*/

        /* does not work chrome
        v = ~~(d.layerY / e),
        d = ~~(d.layerX / e);*/     
        v = ~~(event.offsetY / boxSize) + 1;
        d = ~~(event.offsetX / boxSize);
                
        if (event.type == "mousemove" && isDragging) {
            grid[v][d] = 1;
        }
        else if (event.type != "mousemove") {
        console.log(event);
            grid[v][d] = !grid[v][d];
        }
                    
        draw();
    };

    initializeEmptyMatrix();
    grid = holder;
    updateAndDraw();
})();
/*
var CELL_SIZE = 8,
    X = ~~(b.clientWidth / CELL_SIZE) * CELL_SIZE,
    Y = ~~(b.clientHeight / CELL_SIZE) * CELL_SIZE,
    ONE_HALF = 0.5,
    WIDTH = X / CELL_SIZE,
    HEIGHT = Y / CELL_SIZE,
    emptyGrid = [],
    holderGrid = [],
    grid,
    counter = 0,
    neighbors,
    total,
    z, i, j, mat, h, grid;

for (i = 0; i < HEIGHT; i++) {
    emptyGrid[i] = [];
}

function copyGrid(source) {
    holderGrid = [];
    for (h = 0; h < HEIGHT; h++) {
        holderGrid[h] = source[h].slice(0);
    }   
};

function s() {
    copyGrid(emptyGrid);
    
    for (var h = 0; h < HEIGHT; h++) {
        for (var w = 0; w < WIDTH; w++) {
            // 2-3 neighbors, keep state
            // 3 neighbors = spawn      
            neighbors = calculateNeighbors(h, w);
            if (grid[h][w]) {
                if ((neighbors > 1) && (neighbors < 4)) {
                    holderGrid[h][w] = 1;
                }
            } else {
                if (neighbors == 3) {
                    holderGrid[h][w] = 1;
                }
            }
        }
    }
    
    grid = holderGrid;
    counter++;
};

function calculateNeighbors(y, x) {
    total = grid[y][x] ? -1 : 0;
    for (h = -1; h < 2; h++) {
        for (var w = -1; w < 2; w++) {
            if (grid[(HEIGHT + (y + h)) % HEIGHT][(WIDTH + (x + w)) % WIDTH]) {
                total++;
            }
        }
    }
    return total;
};

function z() {
    for (var h = 0; h < HEIGHT; h++) {
        for (var w = 0; w < WIDTH; w++) {
            if (grid[h][w]) {
                a.fillStyle = "#000";
            } else {
                a.fillStyle = "#eee";
            }           
            a.fillRect(
                w * CELL_SIZE + 1, 
                h * CELL_SIZE + 1, 
                CELL_SIZE - 1, 
                CELL_SIZE - 1);
        }
    }
}

function canvasOnClickHandler(event) {
    var client = "client";
    var scroll = "scroll";
    var offset = "offset";

    var x = event.clientX  - c.offsetLeft;
    var y = event.clientY - c.offsetTop;                
    var yidx = ~~(y / CELL_SIZE );
    var xidx = ~~(x / CELL_SIZE );
    grid[yidx][xidx] = !grid[yidx][xidx];
    z();
};

c.width = X;
c.height = Y;
c.onclick = canvasOnClickHandler;
copyGrid(emptyGrid);
grid = holderGrid;
s();
s();
setInterval("s();z();", 500);
*/
        </script>
    </body>
</html>
